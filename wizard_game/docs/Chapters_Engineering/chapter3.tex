\chapter{Implementation}

\section{Introduction}
In my implementation chapter, the way in which it built the project will be discussed and what was done in the sprints. As it has used a Scrum approach to build the Wizard card game, each iteration of the game has been split into sprints of which specific tasks had to be completed for the sprint to be done.
\section{Sprints}
\subsection{Sprint 1- Setup}
For me to begin the project, there was setup needed to be done to ensure that it can have a safe place to store the project and that it is built in. This was done by setting up a GitLab repository for the Wizard card game to be stored on allowing me to access different versions of the game as it progresses. I also made sure that there was access for my Supervisor to see the progress that I was making. It was also set up a private blog for me to keep track of the progress and problems faced during the implementation. It was also made sure that it had the correct IDE to use on my personal computer for the development of the game. The IDE that was chosen was IntelliJ IDEA 2018 and was chosen for it easy of use and the familiarity with the system. After this was installed and working correctly i added a few initial classes for a idea of what the game will look like. These classes include:
\begin{itemize}
\item AI - The classes to hold all the code for the Artificial Intelligence Players that will be the main players opponents.
\item Card - A constructor class that makes the cards to be used in the deck that initially only contained variables for the suit and value of the cards.
\item Deck - This classes will make and array of cards containing the normal 52 cards deck and the extra 4 wizards and jester cards. This will then be used in the player and game classes to use their cards in its array.
\item Game - This class is to initially contain all the methods for applying the game rules and start the game.
\item Player - the player class will contain methods to bid, play cards and see the cards the player has in his hands. It will also have variables for the score they have and how many tricks they have won in that specific round.
\item Suit - Suit will be a enumerator classes that contains the 4 different suits of heart, spade, diamond and clubs. It will also have a null variable for the jester and wizard cards.
\end{itemize}

This classes will then give me a basic overview of how the project will be initially structured which can then be built on over time. The was problems to begin with linking my local repository to the GitLab one but this was shortly fixed by doing it through the Git Bash rather than the website itself.
\subsection{Sprint 2-Create Shuffled Deck}
For this part of my implementation I tasked myself to create a deck for the Game to use and the for this to be shuffled randomly so it the cards every player will have will be different. This involved create a variable method for generated a normal 52 card deck and then adding the jesters and wizards afterwards. This in order deck would then use a shuffling algorithm\cite{shuffle}, making sure that the player would get different hands each round. This had a simple UI that showed the initial generated deck with all the cards contained in it. This then ordered deck will be shuffled and printed out on the UI in it new shuffled state to show that it has worked and manually tested.
\subsection{Sprint 3-- Create Players and Play Cards}
Creating Player object for the deck to be used for was the next section of work that need to be completed in this iteration. This classes contain variables for a bid to be set; an array of cards for there hand; there current score; how many tricks in that round that have won and the card that would currently be in play for a trick. This would then have getting and setter for the variables to be used. A method to populate the hand of 15 cards from the deck used in the round was also added. This allowed me to create a simple UI that showed the hand that the Player currently holder and be able to select a card from the deck to be used in the game. 
\subsection{Sprint 4 - Create Rounds and Simple AI}
During this sprint, it was tasked to develop rounds for the game to be played and create a simple Artificial intelligence that would randomly bid and select cards from their respective hands. During this part of the process a problem arose in trying to use the AI class as an extension of the Player class. So, it was decided that the best course of action was to create the methods for the AI in the Player class so that it would still function in the game. Another class called round was also added into the system to handle each round of the game containing classes to play the players card until they had no cards left and change the dealer for each trick in the round. This allowed for multiple rounds to be added to the game when and if needed. 
\subsection{Sprint 5 - Apply Rules}
Once the Game functioned properly and the AI was working in a simple but effective for testing way, the next step was to apply to rules of the Wizards card game so that a winner could be decide for each of the rounds. This involve adding a new variable to the player class that counted the amount of trick the player wold win for that round. This would then be used and compared to the bid so that a score can be given to the players. The rules that were added to check who has the best the cards this is done back the wizardRule(), suitRule() and numberRule() methods to find the best card, once the best card has been found the amount of trickswon for the player is increased by one. A new Rules class was added to implement the methods to be referenced containing variable for the players, the winner of the trick and the trump used for the trick.

Another rule that was added was the scoring of the players compared to bid, which checked the difference between the bid and the tricks won and gives a score based on that. I initially had problems as i made the rules a child class of the Round class so that I could reference the trump and players but it would found to be easier to make it a separate class that adds the trump and players from the Round class. Another rule also needed to be added too to make sure that it was working properly which was that the player can only play cards of the same suit at the lead player or the trump card if they are available in there deck. These methods were added into the Round class as problem arose when trying to implement them into the Rules class.
\subsection{Sprint 6 - Monte Carlo Tree Search AI}
For the last and longest of the sprint the Monte Carlo Tree Search Algorithm for the AI. For this sections, a separate package was created called MonteCarlo. The contains the classes for the Tree search to work this include GameState, MonteCarloTreeSearch, Tree and UCT. Below explains each of the classes and what they do:
\begin{itemize}
\item GameState - Contains the data for what state the game is currently in such as what cards are in the players hands and how many tricks they have won. It contains method to get all of the variable to be use in the tree search, an array of all the possible moves that the AI can make in that state and methods to increase the variables that shows the number of visits the node has had and the score it has gotten.
\item MonteCarloTreeSearch - This is the classes that has methods to perform the tree search itself, which includes the selection, expansion, simulation and back propagation parts of the search. This is done under a specific number of iterations to create the tree and then selects the best child node based on the visits and win score and choices the play card used in that node. 
\item Node - This a standard node class created for tree search containing variables for the parent of the node, the child nodes that link to it and the game state for that node. It also contains a class to show which child node has the maximum score in that game state.
\item Tree - The tree class is used to create the tree to be searched to find the best card to be used by the AI. This contains a variable called root and getter and setter to retrieve it. This is then built upon by adding children to this node until a leaf node is reached.
\item UCT - The Upper Confidence Bound applied to Trees (UCT) class is used in the selection part of the Monte Carlo Tree search and find the best node to expand upon based on the ratio of simulation score and the amount of time the node has been visited.

During this part of the project that was a problem with the fact that the player objects were only be referred to as a shallow copy and not a deep copy when being used in the simulation part of the search \cite{copy}. This meant that it only simulated once as it was using the object in the game and not its own player object. This meant a deep copy method was needed to clone the player objects for use in tree search. Once this was done it seemed to work a lot better after a few adjustments to the UCT class.
\end{itemize}
